"""
ckwg +31
Copyright 2015-2017 by Kitware, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither name of Kitware, Inc. nor the names of any contributors may be used
   to endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

==============================================================================

Interface to vital::camera class.

"""
import ctypes

import numpy

from vital.types.covariance import Covariance
from vital.types.eigen import EigenArray
from vital.types.rotation import Rotation
from vital.types.camera_intrinsics import CameraIntrinsics
from vital.util import VitalObject, VitalErrorHandle


class Camera (VitalObject):
    """ vital::camera interface class """

    @classmethod
    def from_krtd_file(cls, filepath):
        """
        :return: New Camera instance from a KRTD format file
        :rtype: Camera
        """
        cam_read_krtd = cls.VITAL_LIB.vital_camera_read_krtd_file
        cam_read_krtd.argtypes = [ctypes.c_char_p, VitalErrorHandle.C_TYPE_PTR]
        cam_read_krtd.restype = cls.C_TYPE_PTR

        with VitalErrorHandle() as eh:
            return cls(from_cptr=cam_read_krtd(filepath, eh))

    @classmethod
    def from_string(cls, s):
        """
        :param s: String camera representation. This must be in the same form
            that would be generated by this class' ``as_string`` method.
        :type s: str
        :return: New camera instance from a string sequence.
        :rtype: Camera
        """
        cam_from_str = cls.VITAL_LIB['vital_camera_new_from_string']
        cam_from_str.argtypes = [ctypes.c_char_p, VitalErrorHandle.c_ptr_type()]
        cam_from_str.restype = cls.c_ptr_type()
        with VitalErrorHandle() as eh:
            cptr = cam_from_str(s, eh)
        return cls(from_cptr=cptr)

    def __init__(self, center=None, rotation=None, intrinsics=None,
                 from_cptr=None):
        """
        Create a new camera instance.

        :param center: Optional center to initialize to. This is the center of
            projection of the camera in the world coordinate system. Default is
            (0, 0, 0).
        :type center: EigenArray | Numpy array

        :param rotation: Optional rotation to initialize to. Otherwise the
            identity rotation is used.
        :type rotation: Rotation

        :param intrinsics: Optional intrinsics to initialize to. Otherwise the
            default intrinsics are used.
        :type intrinsics: CameraIntrinsics

        :param from_cptr: Existing C opaque instance pointer to use, preventing
            new instance construction. This should of course be a valid pointer
            to an instance. Only a new instance pointer or a new shared pointer
            reference should be passed here, otherwise memory issue will ensue.
            Thus this should only be used if you know what you're doing.

        """
        super(Camera, self).__init__(from_cptr, center, rotation, intrinsics)

    def _new(self, center, rotation, intrinsics):
        cam_new = self.VITAL_LIB['vital_camera_new']
        cam_new.argtypes = [EigenArray.c_ptr_type(3, 1, ctypes.c_double),
                            Rotation.c_ptr_type(ctypes.c_double),
                            CameraIntrinsics.c_ptr_type(),
                            VitalErrorHandle.c_ptr_type()]
        cam_new.restype = self.c_ptr_type()

        # Fill in parameter gaps
        if center is None:
            center = EigenArray(3)
            center[:] = 0
        else:
            center = EigenArray.from_iterable(center)

        if rotation is None:
            rotation = Rotation()

        if intrinsics is None:
            intrinsics = CameraIntrinsics()

        with VitalErrorHandle() as eh:
            return cam_new(center, rotation, intrinsics, eh)

    def _destroy(self):
        """ Delete instance through C API """
        if self._inst_ptr:
            cam_del = self.VITAL_LIB.vital_camera_destroy
            cam_del.argtypes = [self.C_TYPE_PTR, VitalErrorHandle.C_TYPE_PTR]

            with VitalErrorHandle() as eh:
                cam_del(self, eh)

    def __eq__(self, other):
        if isinstance(other, Camera):
            return (
                numpy.allclose(self.center, other.center) and
                numpy.allclose(self.translation, other.translation) and
                self.covariance == other.covariance and
                self.rotation == other.rotation and
                self.intrinsics == other.intrinsics
            )
        return False

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        s = numpy.array2string(self.as_matrix(), separator=',')
        s = s[1:-1]  # remove first and last []
        # prefix lines based on the length of the class name
        l = s.splitlines()
        l[0] = ' ' * 9 + '[' + l[0][2:-1]
        l[1] = 'K(R|T) = ' + '[' + l[1][3:-1]
        l[2] = ' ' * 9 + '[' + l[2][3:]
        l.append(str(self.intrinsics))
        return '\n'.join(l)

    def __repr__(self):
        cls_name = self.__class__.__name__
        return ''.join([cls_name, '\n', str(self)])

    def clone(self):
        """
        :return: Return a new instance that is the clone of this one.
        :rtype: Camera
        """
        cptr = self._call_cfunc(
            'vital_camera_clone',
            [self.C_TYPE_PTR], [self],
            self.C_TYPE_PTR
        )
        return Camera(from_cptr=cptr)

    @property
    def center(self):
        """
        :return: a copy of this camera's center coordinate.
        :rtype: EigenArray
        """
        cam_center = self.VITAL_LIB['vital_camera_center']
        cam_center.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_center.restype = EigenArray.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_center(self, eh)
        return EigenArray(3, from_cptr=c_ptr)

    @property
    def translation(self):
        """
        :return: a copy of this camera's translation vector
        :rtype: EigenArray
        """
        cam_trans = self.VITAL_LIB['vital_camera_translation']
        cam_trans.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_trans.restype = EigenArray.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_trans(self, eh)
        return EigenArray(3, from_cptr=c_ptr)

    @property
    def covariance(self):
        """
        :return: a copy of this camera's center covariance
        :rtype: Covariance
        """
        cam_covar = self.VITAL_LIB['vital_camera_center_covar']
        cam_covar.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_covar.restype = Covariance.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_covar(self, eh)
        return Covariance(3, from_cptr=c_ptr)

    @property
    def rotation(self):
        """
        :return: a copy of this camera's rotation
        :rtype: Rotation
        """
        cam_rot = self.VITAL_LIB['vital_camera_rotation']
        cam_rot.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_rot.restype = Rotation.c_ptr_type()
        with VitalErrorHandle() as eh:
            c_ptr = cam_rot(self, eh)
        return Rotation(from_cptr=c_ptr)

    @property
    def intrinsics(self):
        """
        :return: a reference to this camera's intrinsics object
        :rtype: CameraIntrinsics
        """
        cam_int = self.VITAL_LIB['vital_camera_intrinsics']
        cam_int.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_int.restype = CameraIntrinsics.c_ptr_type()
        with VitalErrorHandle() as eh:
            c_ptr = cam_int(self, eh)
        return CameraIntrinsics(from_cptr=c_ptr)

    def as_matrix(self):
        """
        Convert camera into a new 3x4 homogeneous projection matrix.

        :return: new 3x4 homogeneous projection matrix
        :rtype: EigenArray
        """
        cam_asmat = self.VITAL_LIB['vital_camera_as_matrix']
        cam_asmat.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_asmat.restype = EigenArray.c_ptr_type(3, 4)
        with VitalErrorHandle() as eh:
            cptr = cam_asmat(self, eh)
        return EigenArray(3, 4, from_cptr=cptr)

    def as_string(self):
        """
        Convert the camera to a string representation

        :return: String representation of this camera
        :rtype: str
        """
        cam_tostr = self.VITAL_LIB['vital_camera_to_string']
        cam_tostr.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]

        cam_tostr.restype = ctypes.c_void_p
        with VitalErrorHandle() as eh:
            v_ptr = cam_tostr(self, eh)
        s = ctypes.c_char_p(v_ptr).value

        ptr_free = self.VITAL_LIB['vital_free_pointer']
        ptr_free.argtypes = [ctypes.c_void_p]
        ptr_free(v_ptr)

        return s

    def write_krtd_file(self, filepath):
        """
        Write camera object in KRTD format to the specified file.

        :param filepath: Path to the file to write to.
        :type filepath: str

        """
        cam_write_krtd = self.VITAL_LIB.vital_camera_write_krtd_file
        cam_write_krtd.argtypes = [self.C_TYPE_PTR, ctypes.c_char_p,
                                   VitalErrorHandle.C_TYPE_PTR]

        with VitalErrorHandle() as eh:
            cam_write_krtd(self, filepath, eh)

    def project(self, point):
        """
        Project a 3D point into a new 2D image point (eigen array) via this
        camera model.

        :param point: 3D point to transform into the 2D image plane.
        :return: New 2D eigen array that is the transformed point.
        """
        point = EigenArray.from_iterable(point, target_shape=(3, 1))

        cam_project = self.VITAL_LIB['vital_camera_project']
        cam_project.argtypes = [self.c_ptr_type(),
                                EigenArray.c_ptr_type(3),
                                VitalErrorHandle.c_ptr_type()]
        cam_project.restype = EigenArray.c_ptr_type(2)
        with VitalErrorHandle() as eh:
            cptr = cam_project(self, point, eh)
        return EigenArray(2, from_cptr=cptr)

    def depth(self, point):
        """
        Compute the distance of the 3d point to the image plane.

        Points with negative depth are behind the camera.

        :param point: 3D point to find the depth of.

        :return: Depth value
        :rtype: float

        """
        point = EigenArray.from_iterable(point)

        cam_depth = self.VITAL_LIB['vital_camera_depth']
        cam_depth.argtypes = [self.c_ptr_type(),
                              EigenArray.c_ptr_type(3),
                              VitalErrorHandle.c_ptr_type()]
        cam_depth.restype = ctypes.c_double
        with VitalErrorHandle() as eh:
            return cam_depth(self, point, eh)

    def clone_look_at(self, stare_point, up_direction=(0, 0, 1)):
        """
        Create a clone of this camera that is rotated to look at the given point

        The camera should also be rotated about its principal axis such that
        the vertical image direction is closest to \c up_direction in the world.

        :param stare_point: the location at which the camera is oriented to
            point
        :type stare_point: collections.Iterable | numpy.ndarray | EigenArray

        :param up_direction: the vector which is "up" in the world (defaults to
            Z-axis)
        :type up_direction: collections.Iterable | numpy.ndarray | EigenArray

        :return: New camera instance that is the clone of the one given, but set
            to look at the given point.
        :rtype: Camera

        """
        stare_point = EigenArray.from_iterable(stare_point, target_shape=(3, 1))
        up_direction = EigenArray.from_iterable(up_direction,
                                                target_shape=(3, 1))
        cptr = self._call_cfunc(
            'vital_camera_clone_look_at',
            [self.C_TYPE_PTR, EigenArray.c_ptr_type(3),
             EigenArray.c_ptr_type(3)],
            [self, stare_point, up_direction],
            self.C_TYPE_PTR
        )
        return Camera(from_cptr=cptr)
